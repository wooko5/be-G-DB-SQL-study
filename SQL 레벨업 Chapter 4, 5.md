### 2021.08.27 DB 스터디 (SQL 레벨업)

## 4장 집약과 자르기



1. 집약(Aggregation)

   - 집약 함수(Aggregate Function)?

     - 여러 개의 레코드를 한 개의 레코드로 집약하는 SQL 함수를 집약 함수라고 하고, SQL 표준 집약 함수는 다음과 같이 5개가 존재한다

       - COUNT

       - SUM

       - AVG

       - MAX

       - MIN

       - 특별한 경우가 아니면 NULL은 제외한다

         <BR>

   - 여러 개의 레코드를 한 개의 레코드로 집합
     - 집약 쿼리의 실행계획
       - GROUP BY나 윈도우 함수는 실행 시, 내부적으로 집약 조작에 `해시` 알고리즘을 사용한다. 
       - 경우에 따라 `정렬` 알고리즘을 사용하기도 하지만 기본적으로 `해시` 알고리즘을 사용한다. 
     - GROUP BY의  `해시` 알고리즘
       - GROUP BY 구문에 지정되어 있는 필드를 해시함수를 이용해서 해키키로 변환한다
       - 변환된 키들중에 같은 해키 키를 가진 그룹을 모아서 집약한다  
       - 특히 해시의 특성상 GROUP BY 의 유일성이 높을 수록 더 효율적을 작동한다
       - 그러나 해시를 저장할 충분한 메모리나 리소스를 필요로 한다는 점에 유의하자
         - 만약 해시나 정렬을 위한 메모리가 불충분하다면 임시영역을 쓰지만 시스템 저하를 일으킬 수도 있다

2. 자르기

   - 합쳐서 하나

     - GROUP BY는 PARTION BY와 다르게 `자르고, 합치기`를 동시에 한다

       <BR>

   - 파티션(partition)

     - GROUP BY로 잘라 만든 테이블 각각의 부분 집합을 파티션이라고 한다

       <BR>

   - PARTITION BY

     - GROUP BY에서 집약 기능(합치기)를 제외하고 자르기만 남게한 윈도우 함수
     - 이외에 둘의 실질적인 차이는 없지만, PARTITION BY는 CASE식이나 계산 식을 사용한 복잡한 기준에 사용할 수 있다

<br>

<br>

<br>

<BR>

<BR>

<BR>


## 5장 반복문



1. 반복문 의존증

   - 내부적으로는 반복문 사용

     - SQL에는 `관계조작`을 통해 사용자의 최대 생산성 달성이라는 목적을 가지고 있다.

     - 절차지향적인 `반복문`은 SQL 입장에서 최대 생산성 달성에 기여하기 힘들다고 생각이 들어서, 처음부터 반복문을 제외하고 만든 언어가 SQL이다.

     - **그러나 SQL 내부적으로는 반복문을 사용한다**

       <BR>

   - 포장계

     - 여러 행을 한꺼번에 처리하는 SQL, 당연히 행을 하나씩 반복해서 처리하는 반복계 SQL보다 효율성이 좋다

     - 그러나 비즈니스 로직을 포장계 SQL에 많이 넣으면 구문이 복잡해져서 코드의 유지보수성이 떨어진다

       <BR>

       <BR>

       <BR>

2. 반복계의 공포

   - 반복계의 단점

     - 성능

       - ![반복계포장계](https://user-images.githubusercontent.com/58154633/131095698-ab10f3b8-7a7a-4cd7-b7a7-8a8841718061.png)

     - SQL 실행의 오버헤드

       - 오버 헤드란?
         - 오버 헤드는 데이터베이스가 일부 쿼리를 실행하는 데 사용한 임시 디스크 공간이다.
         - 값이 정말 높아질 경우에만 걱정해야한다.
       - 작은 SQL문을 여러 번 수행하는 반복계 SQL은 여러 행을 한꺼번에 처리하는 포장계 SQL에 비해 오버헤드가 커질 수 밖에 없다 

     - 병렬 분산이 힘들다

       - 반복계는 반복 1회 마다의 처리를 굉장히 단순화 한다
       - 따라서 리소스를 분산해서 병렬 처리하는 최적화가 안된다.

     - 데이터베이스 진화로 인한 혜택을 받기 힘들다

       - DBMS는 단순한 SQL 구문과 같은 ‘가벼운’처리를 빠르게 만드는 것은 사실 안중에도 없다. 

       - 따라서 반복계는 미들웨어 또는 하드웨어의 진화에 따른 혜택을 거의 받을 수 없다. 

         <BR>

   - 반복계를 빠르게 만드는 방법은 없을까?

     - 반복계를 포장계로 다시 작성하기

       - 애플리케이션의 수정을 의미한다

     - 각각의 SQL을 빠르게 수정

       - 반복계 SQL구문은 단순하기 때문에 실행 계획을 보아도 `unique scan`또는 `index range scan`정도이고, 또한, `INSERT`구문을 반복하는 경우도 있다. `INSERT`구문은 `SELECT`구문보다 고속화가 더 어렵다. 그래서 튜닝 가능성이 더욱 제한된다.

     - 다중화 처리

       - CPU 또는 디스크와 같은 리소스나 메모리에 여유가 있고, 처리를 나눌 수 있는 키(key)가 명확하게 정해져 있다면, 처리를 다중화해서 성능을 선형(linear)에 가깝게 처리할 수 있다.

       - 물론 애플리케이션 수정이 필요하지만, 처음부터 다중도를 설정할 수 있게 애플리케이션을 구성했다면 코드를 변경하지 않고도 확장 가능

         <BR>

   - 반복계의 장점

     - 실행 계획의 안정성

       - 해당 실행 계회의 변동성이 거의 없다는 것을 의미한다 
       - 반복계는 포장계에 비해 상대적으로 단순하고 작은 SQL구문을 실행하기 때문에 실제 운용 중에 갑자기 실행 계획이 바뀌어 느려지는 현상을 일어나지 않는다

     - 예상 처리 시간의 정밀도

       - ```html
         <처리 시간> = <한 번의 실행 시간> * <실행 횟수>
         ```

       - 실행 계획의 안정성 덕분에 반복계 SQL의 처리 시간의 예측이 용이하다

     - 트랜잭션 관리가 편리하다

       - 갱신 처리를 반복계에서, 특정 반복 횟수마다 커밋한다고 가정하자. 

       - 중간에 오류가 발생했다고 해도, 중간에 커밋을 했으므로 해당 지점 근처에서 다시 처리를 실행하면 되기 때문에 트랜잭션의 미세한 조정이 가능해서 트랜잭션 관리가 편하다 

         <BR>

         <BR>

         <BR>

3. SQL에서는 반복을 어떻게 할까

   - 최대 반복 횟수가 정해진 경우

     - CASE 식과 윈도우함수를 활용한다

     - ```mysql
       SELECT company, year, sale, 
       	CASE SIGN (sale - MAX(sale)
                      OVER (PARTITION BY company
                            ORDER BY year
                            ROWS BETWEEN 1 PRECEDING AND PRECEDING)
                     )
                     WHEN 0 THEN '='
                     WHEN 1 THEN '+'
                     WHEN -1 THEN '-'
                     ELSE NULL END AS var
       FROM Sales;
       ```

   - 반복 회수가 정해지지 않은 경우

     - SQL의 계층 구조를 나타내는 3가지 방법
       - 인접 리스트 모델
         - 전통적인 방식의 계층 구조 방법
       - 중첩 집합 모델
         - 각 레코드의 데이터를 집합으로 보고, 계층 구조를 집합의 중첩 관계로 나타낸다
       - 경로 열거 모델
         - 갱신이 거의 없는 경우에 효율적인 계층 구조 
