### 2021.09.01 DB 스터디 (SQL 레벨업)

## 6장 결합(JOIN)



1. 조인의 종류

   - 기능적 관점 분류
     - 크로스 조인(cross join)
       - 조인이 되는 두 테이블의 모든 레코드를 조합한 결과
       - 카테시안 프로덕트라고도 부르는데 
       - 경우의 수가 너무 커서 비용이 많이 드므로 현업에서는 잘 쓰지 않는다
     - 내부 조인(inner join)
       - 두 개 이상의 테이블에 존재하는 공통 속성의 값이 같은 것을 결과로 추출 == 교집합과 비슷하다고 생각하면 쉽다
       - 가장 많이 사용하는 조인방법 
     - 외부 조인(outer join)
       - right outer join
         - 오른쪽 테이블을 기준으로 왼쪽 테이블을 조인하는 방식
         - 오른쪽 테이블의 A라는 칼럼이 없고 왼쪽 테이블에는 있다면 조인 테이블은 A칼럼을 NULL 처리한다
         - 오른쪽 테이블의 칼럼을 모두 살리는 방식  
       - left outer join
         - 왼쪽 테이블을 기준으로 오른쪽 테이블을 조인하는 방식
         - 왼쪽 테이블의 A라는 칼럼이 없고 오른쪽 테이블에는 있다면 조인 테이블은 A칼럼을 NULL 처리한다
         - 왼쪽 테이블의 칼럼을 모두 살리는 방식  
       - full  outer join
         - 두 테이블의 생략되는 칼럼이 존재하지 않게 하는 외부 조인 방법이다
         - 두 테이블 간의 공통되지 않는 칼럼은 NULL로 처리함 
   - 결합 조건에 따른 분류
     - 등가 조인 == 
     - 비등가 조인 >, <
   - 기타
     - 자기 조인
     - 자연 조인

2. JOIN 알고리즘과 성능

   - 옵티마이저는 다음 3가지 조인 알고리즘 중에 하나를 선택해서 실행한다
     - 중첩 반복(Nested Loops)
       - MySQL에서는 중첩반복만 이용함
     - 해시(Hash)
     - 소트 머지(Sort Merge)

   - 중첩 반복(Nested Loops)

     - 처리방식
       - 구동테이블에서 레코드를 하나씩 반복해서 내부 테이블에 접근한다(이중반복문)
       - ![image-20210901150556134](C:\Users\wooko\AppData\Roaming\Typora\typora-user-images\image-20210901150556134.png)
     - 특징
       - 모든 DBMS에서 지원한다
       - 다른 조인 알고리즘에 비해 메모리 용량을 적게 사용한다
       - 실행시간은 접근하는 레코드 수에 비례한다 (A*B)
       - 구동테이블(drive table, 밖 테이블, A)의 레코드 수가 적을 수록 더 빨라진다
         - 전제: 내부 테이블(B)의 결합 키 필드에 인덱스가 존재하는 경우
     - 단점
       - 결합키로 히트되는 내부 테이블의 레코드 수가 너무 많은 경우 
         - 결합키가 내부 테이블에 대해 유일하지 않은 경우
     - 대처 방법
       - 기존의 공식과는 다르게 레코드 수가 많은 테이블을 구동 테이블로 선정한다
       - 해시 알고리즘을 이용한다

   - Hash

     - 해시란?
       - 입력에 대해 어느 정도 유일성과 균일성을 가진 값을 출력하는 함수를 해시라고 한다

     - 처리방식
       - 작은 테이블을 스캔하기, 결합 키에 해시 함수를 적용해서 해시값으로 변환하기
       - 이어서 다른 테이블(큰 테이블)을 스캔하고, 결합 키가 해시값에 존재하는지 확인하고 JOIN을 수행 
       - ![image-20210901151053326](C:\Users\wooko\AppData\Roaming\Typora\typora-user-images\image-20210901151053326.png)
     - 특징
       - 작은 테이블에서 해시테이블을 만드는 이유
         - 해시 테이블은 DBMS의 워킹 메모리에 저장되므로 조금이라도 작은 것이 효율적이기 때문이다
       - 해시가 사용되는 경우, 어떤 한 쪽의 테이블이 극단적으로 작지 않기 때문에 구동테이블이라 부르는 것은 적절하지 않다
     - 단점
       - JOIN 테이블로부터 해시 테이블을 만들어서 활용하므로, 중첩 반복(Nested Loops)에 비해 메모리를 크게 소모한다
       - 메모리가 부족하면 저장소를 사용하므로 지연이 발생한다
       - 출력되는 해시값은 입력값의 순서를 알지 못 하므로, 등치 결합에만 사용할 수 있다
     - 장점
       - 중첩 반복(Nested Loops)에서 적절한 구동 테이블을 선정할 수 없는 경우, 해시 알고리즘을 사용하면 효율적이다
       - 중첩 반복(Nested Loops) 수행 시, 내부 테이블의 레코드 수가 많은 경우 
       - 중첩 반복(Nested Loops) 수행 시, 내부 테이블에 인덱스가 존재하지 않는 경우

   - Sort Merge

     - 개념
       - Sort Merge는 조인의 대상범위가 넓을 경우 발생하는 Random Access를 줄이기 위한 경우나 연결고리에 마땅한 인덱스가 존재하지 않을 경우 해결하기 위한 조인 방안이다
       - 양쪽 테이블의 처리범위를 각자 Access하여 정렬한 결과를 차례로 Scan하면서 연결고리의 조건으로 Merge하는 방식 
       - 조인 대상 테이블들을 각각 결합 키로 정렬하고, 일치하는 결합 키를 찾으면 결합합니다
     - 특징
       - JOIN - GROUPING의 순서에 따라 효율성이 달라짐
       - 대상 테이블들을 모두 정렬해야하므로 중첩 반복(Nested Loops), 규모에 따라 Hash보다 메모리 효율이 안 좋다
       - 메모리 부족으로 TEMP 탈락이 발생하면 I/O 비용이 커지고 지연 현상이 발생할 수 있다
       - 해시와 다르게 부등호(>=, <=, <, >)를 사용한 조인에도 사용할 수 있지만, 부정조건(<>)에는 사용할 수 없다
       - 테이블이 결합 키로 정렬되어 있다면 정렬을 생략할 수 있다

<br>

<br>

<br>

<BR>

<BR>

<BR>


## 7장 서브쿼리



1. 222
2. 질문
   - 페이지 265
     - `결합 -> 집약` 보다 `집약 -> 결합`이 더 빠른 경우도 존재함
     - 이 둘은 어떤 쪽이 빠른지 환경에도 의존한다. 환경에는 HW, 미들웨어, 결합 알고리즘 등등인데 
     - HW가 어떤 영향을 주는지 궁금 하다