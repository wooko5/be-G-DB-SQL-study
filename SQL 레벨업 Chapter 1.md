### 2021.08.11 DB 스터디 (SQL 레벨업)

## 1장 DBMS 아키텍쳐



1. DBMS 아키텍쳐 개요

   - 쿼리 평가 엔진

     - 사용자로부터 입력받은 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지 결정합니다.

       - **`실행계획(실행플랜)`: 이때 결정되는 계획을 의미** 

       -  `접근 메소드(access method)`: `실행계획`을 기반으로 데이터에 접근하는 방법

         <BR>

   - 버퍼 매니저

     - DBMS는 `버퍼`라는 특별한 메모리를 확보하는데 이 버퍼영역을 관리하는 것이 버퍼매니저

     - 디스크 용량 매니저와 함께 연동되어서 작동

       <BR>

   - 디스크 용량 매니저

     - DB는 데이터가 영구적으로 저장되는 특성상 어디에 어떻게 데이터를 저장할지 관리하는 역할

     - 데이터의 읽기/쓰기를 제어

       <BR>

   - 트랜잭션/락 매니저

     - 트랙잭션의 정합성을 유지하면서 실행하고, 필요한 경우 데이터에 락(lock)을 걸어서 다른 사용자의 요청을 대기 시키는 것이트랜잭션과 락 매니저 역할

     - 트랜잭션은 DB에서 하나의 논리적인 작업 단위를 구성하는 연산들의 집합을 트랜잭션(Transaction)이라고 한다

       - DB 응용프로그램은 트랜잭션의 집합이라고 볼 수 있다

         <BR>

   - 리커버리 매니저 

     - 데이터를 정기적으로 백업하고, DBMS에 문제가 생겼을 시에 데이터를 복구하는 역할

       <BR>

       <BR>

       <BR>

2. DBMS와 버퍼

   - 공짜밥은 존재할까?
     - 기억비용: 데이터를 저장하는데 소비되는 비용

     - `접근속도`와 `기억비용`에는 반비례관계가 존재하기 때문에 DB개발자가 잘 설정해야함

       <BR>

   - DBMS와 기억장치의 관계

     - 1차 기억장치

       - 메모리, 레지스터

     - 2차 기억장치

       - HDD, CD, 플래쉬메모리 등

     - 3차 기억장치

       - 테이프

         <BR>

   - 메모리 위에 있는 두 개의 버퍼

     - 데이터 캐시

       - 디스크에 있는 일부 데이터를 메모리에 유지하기 위해 쓰이는 메모리 영역

     - 로그 버퍼

       - 사용자로부터 DBMS에게 갱신 처리 관련(INSERT, UPDATE, DELETE, MERGE) SQL구문을 명령하면 저장소에 있는 데이터를 변경하기 전에 비동기처리를 위해 임시로 올려놓는 버퍼

         <BR>

   - 메모리의 성질이 초래하는 트레이드 오프

     - 휘발성

       - 전원이 꺼지면 메모리에 올려둔 데이터를 잃는 성질

     - 휘발성의 문제점

       - 로그 버퍼에 올려둔 SQL문이 굉장히 중요한데 갑자기 전원이 꺼져서 사라진다면?
       - 데이터 부정합성이 발생할 수 있다

     - 해결

       - DBMS는 COMMIT 시점에 반드시 갱신 정보를 로그 파일(영속적인 저장소 위에 존재)을 만들어내서 데이터의 정합성을 유지

         <BR>

   - 시스템 특성에 따른 트레이드 오프

     - 데이터 캐시와 로그버퍼의 크기

       - 대부분 DBMS에서 메모리 영역의 로그 버퍼와 데이터 캐시의 크기를 다르게 해놓음

       - 왜냐하면 사용자는 거의 갱신보다 검색 수행 시 더 많은 처리량을 요구하기 때문에

       - 그래서 로그버퍼의 크기는 데이터 캐시에 비해 작다

         <BR>

   - 추가적인 메모리 영역 `워킹메모리`

     - 정렬 OR 해시 관련 처리에 사용되는 작업용 영역(메모리 안에 존재)을 워킹 메모리라고 함

     - 만약에 수행 시 워킹메모리 크기가 부족하다면?

       - 메모리가 아닌 `저장소`에 존재하는 `일시 영역(임시 테이블 스페이스)`를 통해 처리한다(일시 영역은 상대적으로 느리다)

       - 이때 메모리 영역의 워킹메모리와 저장소에 존재하는 일시 영역가 번갈아가면서 처리를 하기 때문에 속도의 변화가 유동적이다 

         <BR>

         <BR>

         <BR>

3. DBMS와 실행 계획

   - 권한 이양의 죄악

     - SQL은 절차적인 세부사항(데이터 검색, 갱신 등)을 기술하지 않고 사용하는 불편한 언어

     - RDB는 시스템이 `사용자가 데이터에 접근하기 위한 절차`를 책임진다(타 언어는 사용자가 책임)

       - 생산성 향상을 위해  

         <BR>

   - 데이터에 접근하는 방법은 어떻게 정할까

     - 쿼리 평가 엔진은 SQL구문을 처음으로 읽어들이는 모듈이고 이 모듈은 아래와 같이 구성되어 있다

     - 파서(Parser)

       - 사용자로부터 입력받은 SQL구문을 검사해주고 분석해서 DBSM가 이해할 수 있는 수준으로 변환해주는 역할

     - 옵티마이저(Optimizer)

       - 파서로부터 받은 SQL구문을 통해 `데이터 접근법(실행 계획)`을 작성하고, `비용을 연산`하고, 가장 낮은 비용의 실행 계획을 선택하는 역할
       - DBMS의 핵심 두뇌

     - 카탈로그 매니저(Catalog manger, 통계 정보)

       - 옵티마이저가 최적의 선택을 할 수 있도록 테이블 OR 인덱스에 대한 통계 정보를 알려주는 역할
       - 각 테이블의 레코드 수, 필드 수와 크기, 필드의 카디널리티, 필드값의 분포도, 필드 내부에 있는 NULL 개수, 인덱스 정보 

     - 플랜 평가(Plan evaluation)

       - 옵티마이저에서 세운 여러가지 실행 계획 중에 가장 낮은 비용의 실행 계획을 선택하는 역할

       <BR>

   - 옵티마이저와 통계정보

     - 옵티마이저가 항상 최적의 실행 계획을 선택하는 것이 아니기 때문에 개발자가 신경써줘야함
       - 최적의 실행계획이 작성되게 하려면 옵티마이저 자체를 수정하는 방식보다는 카탈로그 매니저에 들어갈 정보를 갱신해주는 것이 더 효율적

     <BR>

     <BR>

     <BR>

4. 실행 계획이 SQL 구문의 성능을 결정

   - 실행 계획 확인 방법
   - 테이블 풀 스캔의 실행 계획
     - 조작대상 객체
     - 객체에 대한 조작의 종류
     - 조작 대상이 되는 레코드 수
   - 인덱스 스캔의 실행 계획
   - 간단한 테이블 결합의 실행 계획
     - Nested Loop
       - a 테이블의 레코드를 하나씩 읽으면서 결합 조건에 맞는 레코드를 b 테이블에서 찾는 방식
       - innner join이 대표적(두 테이블 간에 조건에 부합하는 레코드를 찾는 결합방식)
     - Sort Merge
       - 결합 키로 레코드를 정렬하고, 순차적으로 두 개의 테이블을 결합하는 방법
     - Hash